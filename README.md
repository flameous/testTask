# Task

Задача в том, чтобы реализовать на Go эффективный модуль кеширования в памяти приложения. Интерфейс 
```go
func Get(key string, getter func() (interface{}, error)) (interface{}, error)
```
 
где `key` — ключ кеширования, и `getter` — анонимная функция, непосредственно получающая данные. 
заданы константы: время валидности кеша, и время, через которое кеш должен асинхронно обновиться. 
Задача в том, чтобы: 
1. `getter` исполнялся минимально необходимое число раз
2. на ошибку `getter`’а возвращать ошибку всем ожидающим
3. при наличии валидных данных в кеше они сразу возвращались на запрос

Код должен быть соответствовать требованиям и не содержать race condition, что должно быть подтверждено тестами. 

Для упрощения задания время работы `getter`’а не ограничено, инвалидация и очистка старых данных в кеше не нужна.

# Review

>По тестовому заданию, чуть подробнее:
>1. Чтение через единый mutex — плохая идея. В оптимистичном сценарии это должны быть атомарные операции (типа `rw.Mutex.RLock`)
>2. Создавать функцию в цикле — очень плохая идея — там довольно жирная аллокация. Аналогично с defer — в 2-строчных функциях лучше без него.
>3. Самая большая проблема: getter'ы запускаются в 1 поток. В реальном продакшене туда при старте приложения в первые секунды придёт несколько тысяч новых запросов кеша, и будет разгребаться медленнее, чем заполняться.
>4. Есть ряд рейсов. Например, список receiver'ов может пополниться после чтения из него, но до чтения из кеша. Плохо, что это не поймали тесты.
>5. Частая очистка кеша — дорогая и не очень обязательная процедура.

Juny 19th (2016)
